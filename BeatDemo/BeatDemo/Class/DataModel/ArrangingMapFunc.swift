//
//  ArrangingMapFunc.swift
//  BeatDemo
//
//  Created by X Young. on 2018/9/6.
//  Copyright ¬© 2018Âπ¥ X Young. All rights reserved.
//

import UIKit
import SwiftyXMLParser

class ArrangingMapFunc: NSObject {
    /// ÁîüÊàê‰∏Ä‰∏™ÁºñÊõ≤ÂõæË∞±Model
    static func initOneReferenceTrack() -> ReferenceTrackMessage {
        let model = ReferenceTrackMessage.init()
        model.sectionNumInParagraph = [1, 9, 17, 18]
        model.secondsInOneSection = 3.0
        model.totalSectionsNum = 18
        
        // MARK: - ÊµãËØïÊï∞ÊçÆ
        model.beatConstitutionTypeArray = [.Type2222]
        model.strongLevelInformationInSection = [.Weak]
        
        let instrumentRange = InstrumentRange.init()
        instrumentRange.name = "üé∏"
        instrumentRange.lowestMidiNum = 50
        instrumentRange.highestMidiNum = 56
        model.variousInstrumentArray = [ instrumentRange ]
        
        let harmonyMessage = HarmonyMessage.init()
        harmonyMessage.scale = []
        model.harmonyMessageArray = [harmonyMessage]
        
        
        let topicSentence = TopicSentence.init()
        topicSentence.mainTone = 50
        topicSentence.location = [0, 8]
        model.topicSentenceArray = [topicSentence]
        
        let chordMessage = ChordMessage.init()
        chordMessage.location = [0,9]
        chordMessage.tonality = "A"
        model.chordMessageArray = [chordMessage]
        
        
        return model
    }// funcEnd
    
    
    /// ÁîüÊàêÂíåÂ£∞ËäÇÂ•èÂ±Ç
    static func generateHarmonyLevel(_ model: ReferenceTrackMessage, instrumentName: String, startSection: Int, endSection: Int) -> [NoteEvent] {

        // ÊâæÂà∞ÈÄâÂÆöÁöÑ‰πêÂô®
        var selectInstrument: InstrumentRange? = nil
        for variousInstrument in model.variousInstrumentArray {
            if variousInstrument.name == instrumentName {
                selectInstrument = variousInstrument
            }
        }
        
        // Ê≤°ÊúâÂåπÈÖçÁöÑ‰πêÂô®Áõ¥Êé•ËøîÂõûÁ©∫Êï∞ÁªÑ
        if selectInstrument == nil {
            return []
        }
        
        // ÂåπÈÖçÂØπÂ∫îÁöÑÂíåÂ£∞‰ø°ÊÅØÊï∞ÁªÑ
        var selectHarmonyMessage: HarmonyMessage? = nil
        for harmonyMessage in model.harmonyMessageArray {
            if harmonyMessage.startBeat == startSection * model.beatsNumInSection {
                selectHarmonyMessage = harmonyMessage
            }
        }
        
        // Ê≤°ÊúâÂåπÈÖçÁöÑÂíåÂ£∞‰ø°ÊÅØÁõ¥Êé•ËøîÂõûÁ©∫Êï∞ÁªÑ
        if selectHarmonyMessage == nil {
            return []
        }
        
        // ÊâæÂà∞Âú®ÈÄâÂÆö‰πêÂô®Èü≥ÂüüÂÜÖÁöÑÈü≥È´ò
        var suitableScaleArray: [Int] = []
        for tmpScale in selectHarmonyMessage!.scale {
            if tmpScale > selectInstrument!.highestMidiNum { // ‰∏çÂêàÈÄÇ?
                suitableScaleArray.append(self.getMidiNoteFrom(tmpScale, highestMidiNum: selectInstrument!.highestMidiNum))
                
            }else { // ÂêàÈÄÇÁõ¥Êé•ÂÆâÊéí‰∏ä‰∫Ü
                suitableScaleArray.append(tmpScale)
                
            }
            
        }
        
        // Âú®ÂêàÈÄÇÁöÑÈü≥Á¨¶ÈáåÁîüÊàêÊï∞ÁªÑ
        var noteEventArray: [NoteEvent] = []
        let interval = Double.init(endSection - startSection) / Double.init(suitableScaleArray.count)
        
        for suitableScale in suitableScaleArray {
            let noteEvent = NoteEvent.init(startNoteNumber: UInt8(suitableScale),
                                           startTime: Double.init(startSection) * model.secondsInOneSection,
                                           endTime: Double.init(startSection) * model.secondsInOneSection + interval,
                                           passedNotes: nil)
            
            noteEventArray.append(noteEvent)
        }
        
        return noteEventArray
        
    }// funcEnd
    
    
    /// ÁîüÊàêÂ§çÊùÇËäÇÂ•èÂ±Ç
    static func generateComplexRhythmLevel(_ model: ReferenceTrackMessage, instrumentName: String) -> [NoteEvent] {
        
        var array: [NoteEvent] = []
        
        // ÂΩìÂâçÂ∞èËäÇ
        var sectionIndex: Double = 0
        
        for beatConstitutionType in model.beatConstitutionTypeArray {
            // Ëé∑ÂèñÊãçÂ≠êÁªìÊûÑÊï∞ÁªÑ
            let beatGroup = self.getBeatGroup(beatConstitutionType)
            
            var lastBeatIndex = 0
            // ÈÅçÂéÜÊãçÂ≠êÁªìÊûÑÊï∞ÁªÑËé∑ÂèñÊØè‰∏™ÊãçÂ≠êÁªÑÊòØÂê¶ÊúâÈü≥
            for beat in beatGroup {
                lastBeatIndex += beat
                
                /// ÂΩìÂâçÊãçÂ≠êÁªÑÁªìÊùüÊó∂Èó¥
                let lastTime = sectionIndex * model.secondsInOneSection + Double.init(lastBeatIndex * 3) / 16
                
                // 1Ê≤°Êúâ2Êúâ
                let isHaveNote = ToolClass.randomInRange(range: 1 ... 2)
                if isHaveNote == 2 {
                    /// ÂΩìÂâçÈü≥Á¨¶ÈïøÂ∫¶
                    let noteLength = ToolClass.randomInRange(range: 1 ... beat)
                    /// ÂΩìÂâçÊãç
                    let totalBeatIndex = Int.init(sectionIndex) * 16 + lastBeatIndex
                    /// ÂΩìÂâçÂíåÂ£∞Èü≥Á¨¶
                    if let midiNote = self.getMidiNoteFrom(totalBeatIndex, harmonyMessageArray: model.harmonyMessageArray) {
                        
                        // ËøîÂõûÈÄâÂÆöÁöÑ‰πêÂô®
                        let instrumenthighNote: Int = {
                            for range in model.variousInstrumentArray {
                                if range.name == instrumentName {
                                    return range.highestMidiNum
                                }
                            }
                            
                            return 0
                        }()

                        let tmpMideNote = UInt8(self.getMidiNoteFrom(midiNote, highestMidiNum: instrumenthighNote))
                        
                        let note = NoteEvent.init(startNoteNumber: tmpMideNote,
                                                  startTime: lastTime - Double.init(noteLength * 3) / 16 ,
                                                  endTime: lastTime,
                                                  passedNotes: nil)
                        array.append(note)
                    }
                    
                }
                
                if lastBeatIndex == 16 {
                    lastBeatIndex = 0
                }
            }
            
            
            sectionIndex += 1
        }

        
        

        return array
        
    }// funcEnd
    
    /// ‰ªéXMLÊñá‰ª∂‰∏≠ÊèêÂèñÂíåÂ£∞‰ø°ÊÅØÊï∞ÁªÑ
    static func getHarmonyMessageArray(_ fileName: String) -> [HarmonyMessage] {
        let filePath = Bundle.main.path(forResource: fileName, ofType: nil)
        if filePath == nil {
            return []
            
        }
        
        let xml = try! XML.parse(Data.init(contentsOf: URL.init(fileURLWithPath: filePath!)))
        // Ëé∑ÂèñÂ∞èËäÇÁöÑÈõÜÂêà
        let sectionSet = xml.element!.childElements[0].childElements[3].childElements
        
        var array: [HarmonyMessage] = []
        
        for sectionIndex in 0 ..< 18 {
            let item = HarmonyMessage.init()
            item.startBeat = sectionIndex * 16
            item.endBeat = item.startBeat + 16
            
            let sectionXml = sectionSet[sectionIndex].childElements
            
            for note in sectionXml {
                
                if note.name == "note" {
                    
                    for pitch in note.childElements {
                        
                        if pitch.name == "pitch" {
                            
                            var scaleName = "1"
                            var octaveCount = 0
                            var isRising = false
                            
                            // ‰∏∫ÊØè‰∏™‰ø°ÊÅØËµãÂÄº
                            for pitchChildren in pitch.childElements {
                                switch pitchChildren.name {
                                case "step":
                                    scaleName = pitchChildren.text!
                                    
                                case "octave":
                                    octaveCount = Int(pitchChildren.text!)! - 2
                                    
                                case "alter":
                                    isRising = true
                    
                                default:
                                    print("?")
                                }
                                
                            }
                            
                            // Ëé∑ÂæóÈü≥Á¨¶
                            let midiNote = self.getMidiNote(scaleName, octaveCount: octaveCount, isRising: isRising)
                            
                            item.scale.append(midiNote)
                            
                        }
                        
                    }
                    
                }
                
            }
            
            array.append(item)
        }
        
        return array
    }// funcEnd
    
    
    /// ÁªôÂÆö‰∏Ä‰∏™Èü≥Èò∂‰∏éÂÖ´Â∫¶‰ø°ÊÅØ ËøîÂõûmidiÈü≥Á¨¶Êï∞Â≠ó
    static func getMidiNote(_ scaleName: String, octaveCount: Int, isRising: Bool?) -> Int {
        var tmpScale = 0
        
        switch scaleName {
        case "A":
            tmpScale = 9
            
        case "B":
            tmpScale = 11
            
        case "C":
            tmpScale = 0
            
        case "D":
            tmpScale = 2
            
        case "E":
            tmpScale = 4
            
        case "F":
            tmpScale = 5
            
        case "G":
            tmpScale = 7

        default:
            return 0
        }
        
        if isRising != true {
            return tmpScale + octaveCount * 12
            
        }else {
            return tmpScale + octaveCount * 12 + 1
            
        }
        
    }// funcEnd
    
    
// MARK: - ÁßÅÊúâÊñπÊ≥ï
    /// ÁªôÂÆö‰∏Ä‰∏™Èü≥Âüü‰∏é‰∏Ä‰∏™Á°ÆÂÆöÁöÑÈü≥È´ò, ËøîÂõûÂú®ËØ•Èü≥ÂüüÂÜÖÁöÑ‰∏Ä‰∏™Èü≥Á¨¶ [‰πêÂô®]
    static private func getMidiNoteFrom(_ scale: Int, highestMidiNum: Int) -> Int {
        
        var tmpScale = scale
        while tmpScale > highestMidiNum {
            tmpScale -= 12
            
        }
        
        return tmpScale
    }// funcEnd
    
    /// ÁªôÂÆöÊãçÂ≠êÁöÑÂ∫èÂè∑, ËøîÂõû‰∏Ä‰∏™Èü≥Á¨¶
    static private func getMidiNoteFrom(_ beatIndex: Int, harmonyMessageArray: [HarmonyMessage]) -> Int? {
        for harmonyMessage in harmonyMessageArray {
            if beatIndex >= harmonyMessage.startBeat && beatIndex <= harmonyMessage.endBeat {
                return harmonyMessage.scale.first!
                
            }
            
        }
        
        return nil
    }
    
    
    /// ÁªôÂÆö‰∏Ä‰∏™ÊãçÁÇπÊûÑÊàêÁ±ªÂûã, ËøîÂõû‰∏Ä‰∏™Â∞èËäÇÂÜÖÁöÑÊãçÂ≠êÊûÑÊàê
    static private func getBeatGroup(_ type: BeatConstitutionType) -> [Int] {
        switch type {
        case .Type2222:
            return [4, 4, 4, 4]
            
        case .Type233:
            return [4, 6, 6]
            
        case .Type323:
            return [6, 4, 6]
            
        case .Type332:
            return [6, 6, 4]
            
        }
    }// funcEnd
    
    
}
